'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserManagerInstance = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _isEmpty;

function _load_isEmpty() {
  return _isEmpty = _interopRequireDefault(require('lodash/isEmpty'));
}

var _freeportAsync;

function _load_freeportAsync() {
  return _freeportAsync = _interopRequireDefault(require('freeport-async'));
}

var _http = _interopRequireDefault(require('http'));

var _querystring = _interopRequireDefault(require('querystring'));

var _opn;

function _load_opn() {
  return _opn = _interopRequireDefault(require('opn'));
}

var _util;

function _load_util() {
  return _util = _interopRequireDefault(require('util.promisify'));
}

var _ApiV;

function _load_ApiV() {
  return _ApiV = _interopRequireDefault(require('./ApiV2'));
}

var _ApiV2;

function _load_ApiV2() {
  return _ApiV2 = require('./ApiV2');
}

var _Analytics;

function _load_Analytics() {
  return _Analytics = _interopRequireWildcard(require('./Analytics'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('./Config'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _Intercom;

function _load_Intercom() {
  return _Intercom = _interopRequireWildcard(require('./Intercom'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

var _Utils;

function _load_Utils() {
  return _Utils = require('./Utils');
}

var _EnvironmentHelper;

function _load_EnvironmentHelper() {
  return _EnvironmentHelper = require('./tools/EnvironmentHelper');
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class UserManagerInstance {
  constructor() {
    this.loginServer = null;
    this.refreshSessionThreshold = 60 * 60;
    this._currentUser = null;
    this._getSessionLock = new (_Utils || _load_Utils()).Semaphore();
  } // 1 hour


  static getGlobalInstance() {
    if (!__globalInstance) {
      __globalInstance = new UserManagerInstance();
    }
    return __globalInstance;
  }

  initialize() {
    this.loginServer = null;
    this._currentUser = null;
    this._getSessionLock = new (_Utils || _load_Utils()).Semaphore();
  }

  /**
   * Logs in a user for a given login type.
   *
   * Valid login types are:
   *  - "user-pass": Username and password authentication
   *
   * If the login type is "user-pass", we directly make the request to www
   * to login a user.
   */
  loginAsync(loginType, loginArgs) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (loginType === 'user-pass') {
        if (!loginArgs) {
          throw new Error(`The 'user-pass' login type requires a username and password.`);
        }
        const apiAnonymous = (_ApiV || _load_ApiV()).default.clientForUser();
        const loginResp = yield apiAnonymous.postAsync('auth/loginAsync', {
          username: loginArgs.username,
          password: loginArgs.password
        });
        if (loginResp.error) {
          throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_USERNAME_PASSWORD, loginResp['error_description']);
        }
        return _this._getProfileAsync({
          currentConnection: 'Username-Password-Authentication',
          sessionSecret: loginResp.sessionSecret
        });
      } else {
        throw new Error(`Invalid login type provided. Must be 'user-pass'.`);
      }
    })();
  }

  registerAsync(userData, user) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (!user) {
        user = yield _this2.getCurrentUserAsync();
      }

      if (user) {
        yield _this2.logoutAsync();
        user = null;
      }

      try {
        // Create or update the profile
        let registeredUser = yield _this2.createOrUpdateUserAsync({
          connection: 'Username-Password-Authentication', // Always create/update username password
          email: userData.email,
          givenName: userData.givenName,
          familyName: userData.familyName,
          username: userData.username,
          password: userData.password
        });

        registeredUser = yield _this2.loginAsync('user-pass', {
          username: userData.username,
          password: userData.password
        });

        return registeredUser;
      } catch (e) {
        console.error(e);
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.REGISTRATION_ERROR, 'Error registering user: ' + e.message);
      }
    })();
  }

  /**
   * Ensure user is logged in and has a valid token.
   *
   * If there are any issues with the login, this method throws.
   */
  ensureLoggedInAsync() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if ((_Config || _load_Config()).default.offline) {
        return null;
      }

      let user = yield _this3.getCurrentUserAsync();
      if (!user && _this3._interactiveAuthenticationCallbackAsync) {
        user = yield _this3._interactiveAuthenticationCallbackAsync();
      }
      if (!user) {
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NOT_LOGGED_IN, 'Not logged in');
      }
      return user;
    })();
  }

  setInteractiveAuthenticationCallback(callback) {
    this._interactiveAuthenticationCallbackAsync = callback;
  }

  _readUserData() {
    return _asyncToGenerator(function* () {
      let auth = yield (_UserSettings || _load_UserSettings()).default.getAsync('auth', {});
      if ((0, (_isEmpty || _load_isEmpty()).default)(auth)) {
        // XXX(ville):
        // We sometimes read an empty string from ~/.expo/state.json,
        // even though it has valid credentials in it.
        // We don't know why.
        // An empty string can't be parsed as JSON, so an empty default object is returned.
        // In this case, retrying usually helps.
        auth = yield (_UserSettings || _load_UserSettings()).default.getAsync('auth', {});
      }
      return auth;
    })();
  }

  /**
   * Get the current user based on the available token.
   * If there is no current token, returns null.
   */
  getCurrentUserAsync() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      yield _this4._getSessionLock.acquire();

      try {
        // If user is cached and there is a sessionSecret, return the user
        if (_this4._currentUser && _this4._currentUser.sessionSecret) {
          return _this4._currentUser;
        }

        if ((_Config || _load_Config()).default.offline) {
          return null;
        }

        let { currentConnection, sessionSecret } = yield _this4._readUserData();

        // No session, no current user. Need to login
        if (!sessionSecret) {
          return null;
        }

        try {
          return yield _this4._getProfileAsync({
            currentConnection,
            sessionSecret
          });
        } catch (e) {
          (_Logger || _load_Logger()).default.global.warn('Fetching the user profile failed');
          (_Logger || _load_Logger()).default.global.warn(e);
          return null;
        }
      } finally {
        _this4._getSessionLock.release();
      }
    })();
  }

  getCurrentUsernameAsync() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      let data = yield _this5._readUserData();
      if (!data.username) {
        return null;
      }
      return data.username;
    })();
  }

  getSessionAsync() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      let data = yield _this6._readUserData();
      if (!data.sessionSecret) {
        return null;
      }
      return { sessionSecret: data.sessionSecret };
    })();
  }

  /**
   * Create or update a user.
   */
  createOrUpdateUserAsync(userData) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      let currentUser = _this7._currentUser;
      if (!currentUser) {
        // attempt to get the current user
        currentUser = yield _this7.getCurrentUserAsync();
      }

      try {
        const api = (_ApiV || _load_ApiV()).default.clientForUser(currentUser);

        const { user: updatedUser } = yield api.postAsync('auth/createOrUpdateUser', {
          userData: _prepareAuth0Profile(userData)
        });

        _this7._currentUser = _extends({}, _this7._currentUser || {}, _parseAuth0Profile(updatedUser));
        return _extends({
          kind: 'user'
        }, _this7._currentUser);
      } catch (e) {
        const err = e;
        if (err.code === 'AUTHENTICATION_ERROR') {
          throw new Error(err.details.message);
        }
        throw e;
      }
    })();
  }

  /**
   * Logout
   */
  logoutAsync() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      if (_this8._currentUser) {
        (_Analytics || _load_Analytics()).logEvent('Logout', {
          username: _this8._currentUser.username
        });
      }

      _this8._currentUser = null;

      // Delete saved auth info
      yield (_UserSettings || _load_UserSettings()).default.deleteKeyAsync('auth');

      // Logout of Intercom
      (_Intercom || _load_Intercom()).update(null);
    })();
  }

  /**
   * Forgot Password
   */
  forgotPasswordAsync(usernameOrEmail) {
    return _asyncToGenerator(function* () {
      const apiAnonymous = (_ApiV || _load_ApiV()).default.clientForUser();
      return apiAnonymous.postAsync('auth/forgotPasswordAsync', {
        usernameOrEmail
      });
    })();
  }

  /**
   * Get profile given token data. Errors if token is not valid or if no
   * user profile is returned.
   *
   * This method is called by all public authentication methods of `UserManager`
   * except `logoutAsync`. Therefore, we use this method as a way to:
   *  - update the UserSettings store with the current token and user id
   *  - update UserManager._currentUser
   *  - Fire login analytics events
   *  - Update the currently assigned Intercom user
   *
   * Also updates UserManager._currentUser.
   *
   * @private
   */
  _getProfileAsync({
    currentConnection,
    sessionSecret
  }) {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      let user;
      let api = (_ApiV || _load_ApiV()).default.clientForUser({
        sessionSecret
      });

      user = yield api.postAsync('auth/userProfileAsync');

      if (!user) {
        throw new Error('Unable to fetch user.');
      }

      user = _extends({}, _parseAuth0Profile(user), {
        kind: 'user',
        currentConnection,
        sessionSecret
      });

      yield (_UserSettings || _load_UserSettings()).default.mergeAsync({
        auth: {
          userId: user.userId,
          username: user.username,
          currentConnection,
          sessionSecret
        }
      });

      // If no currentUser, or currentUser.id differs from profiles
      // user id, that means we have a new login
      if ((!_this9._currentUser || _this9._currentUser.userId !== user.userId) && user.username && user.username !== '') {
        (_Analytics || _load_Analytics()).logEvent('Login', {
          userId: user.userId,
          currentConnection: user.currentConnection,
          username: user.username
        });

        (_Analytics || _load_Analytics()).setUserProperties(user.username, {
          userId: user.userId,
          currentConnection: user.currentConnection,
          username: user.username
        });

        if (user.intercomUserHash) {
          (_Intercom || _load_Intercom()).update(user);
        }
      } else {
        (_Intercom || _load_Intercom()).update(null);
      }

      _this9._currentUser = user;

      return user;
    })();
  }
}

exports.UserManagerInstance = UserManagerInstance;
let __globalInstance;
exports.default = UserManagerInstance.getGlobalInstance();

/** Private Methods **/

function _parseAuth0Profile(rawProfile) {
  if (!rawProfile || typeof rawProfile !== 'object') {
    return rawProfile;
  }
  return Object.keys(rawProfile).reduce((p, key) => {
    p[(_lodash || _load_lodash()).default.camelCase(key)] = _parseAuth0Profile(rawProfile[key]);
    return p;
  }, {});
}

function _prepareAuth0Profile(niceProfile) {
  if (typeof niceProfile !== 'object') {
    return niceProfile;
  }

  return Object.keys(niceProfile).reduce((p, key) => {
    p[(_lodash || _load_lodash()).default.snakeCase(key)] = _prepareAuth0Profile(niceProfile[key]);
    return p;
  }, {});
}
//# sourceMappingURL=__sourcemaps__/User.js.map
