{"version":3,"sources":["ThirdParty.js"],"names":["async","publicUrl","opts","req","url","method","headers","Accept","let","exp","resp","await","axios","request","data","e","ErrorCode","INVALID_MANIFEST","toString","_extractManifest","platform","getManifest","expOrArray","Array","isArray","sdkVersions","Versions","versionsAsync","i","length","manifestCandidate","sdkVersion","versionObj","isDeprecated","supportedVersions","Object","keys","JSON","stringify"],"mappings":";;;;;;;;+BAKOA,WAA2BC,SAA3BD,EAAsCE,OAAO,EAA7CF,EAAiD;AACtD,UAAMG,MAAM;AACVC,WAAKH,SADK;AAEVI,cAAQ,KAFE;AAGVC,eAAS,EAAEC,QAAQ,wCAAV;AAHC,KAAZ;;AAMAC,QAAIC,GAAJD;AACA,QAAI;AACF,YAAME,OAAOC,MAAMC,kCAAMC,OAAND,CAAcT,GAAdS,CAAnB;AACAH,YAAMC,KAAKI,IAAXL;AACF,KAHA,CAGE,OAAOM,CAAP,EAAU;AACV,YAAM,4CACJC,0CAAUC,gBADN,EAEH,iCAAgChB,SAAU,IAA3C,GAAiDc,EAAEG,QAAFH,EAF7C,CAAN;AAIF;AACAN,UAAME,MAAMQ,iBAAiBV,GAAjBU,EAAsBlB,SAAtBkB,CAAZV;AACA,QAAIP,KAAKkB,QAALlB,IAAiBO,IAAIW,QAAJX,KAAiBP,KAAKkB,QAAvClB,IAAmDA,KAAKkB,QAALlB,KAAkB,KAAzE,EAAgF;AAC9E,YAAM,4CACJc,0CAAUC,gBADN,EAEH,iBAAgBhB,SAAU,+BAA8BC,KAAKkB,QAAS,WAFnE,CAAN;AAIF;AACA,WAAOX,GAAP;AACF,G;;kBAzBsBY,W;;;;;AA2BtB;AACA;;;;gCACArB,WAAgCsB,UAAhCtB,EAA4CC,SAA5CD,EAAuD;AACrD;AACA,QAAI,CAACuB,MAAMC,OAAND,CAAcD,UAAdC,CAAL,EAAgC;AAC9B,aAAOD,UAAP;AACF;;AAEA,UAAM,EAAEG,WAAF,KAAkBd,MAAMe,gCAASC,aAATD,EAA9B;AACA,SAAKlB,IAAIoB,IAAI,CAAb,EAAgBA,IAAIN,WAAWO,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C,YAAME,oBAAoBR,WAAWM,CAAXN,CAA1B;AACA,YAAMS,aAAaD,kBAAkBC,UAArC;AACA,UAAI,CAACA,UAAL,EAAiB;AACf;AACF;AACA,YAAMC,aAAaP,YAAYM,UAAZN,CAAnB;AACA,UAAI,CAACO,UAAL,EAAiB;AACf;AACF;;AAEA,YAAMC,eAAeD,WAAWC,YAAXD,IAA2B,KAAhD;AACA,UAAI,CAACC,YAAL,EAAmB;AACjB,eAAOH,iBAAP;AACF;AACF;AACA,UAAMI,oBAAoBC,OAAOC,IAAPD,CAAYV,WAAZU,CAA1B;AACA,UAAM,4CACJnB,0CAAUC,gBADN,EAEH,mCAAkChB,SAAU,mDAAkDoC,KAAKC,SAALD,CAC7FH,iBAD6FG,CAE7F,EAJE,CAAN;AAMF,G;;kBA9BelB,gB;;;;;;;AAlCf;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA","file":"../ThirdParty.js","sourcesContent":["import axios from 'axios';\nimport ErrorCode from './ErrorCode';\nimport * as Versions from './Versions';\nimport XDLError from './XDLError';\n\nexport async function getManifest(publicUrl, opts = {}) {\n  const req = {\n    url: publicUrl,\n    method: 'get',\n    headers: { Accept: 'application/expo+json,application/json' },\n  };\n\n  let exp;\n  try {\n    const resp = await axios.request(req);\n    exp = resp.data;\n  } catch (e) {\n    throw new XDLError(\n      ErrorCode.INVALID_MANIFEST,\n      `Unable to fetch manifest from ${publicUrl}. ` + e.toString()\n    );\n  }\n  exp = await _extractManifest(exp, publicUrl);\n  if (opts.platform && exp.platform !== opts.platform && opts.platform !== 'all') {\n    throw new XDLError(\n      ErrorCode.INVALID_MANIFEST,\n      `Manifest from ${publicUrl} is not compatible with the ${opts.platform} platform`\n    );\n  }\n  return exp;\n}\n\n// Third party publicUrls can return an array of manifests\n// We need to choose the first compatible one\nasync function _extractManifest(expOrArray, publicUrl) {\n  // if its not an array, assume it was a single manifest obj\n  if (!Array.isArray(expOrArray)) {\n    return expOrArray;\n  }\n\n  const { sdkVersions } = await Versions.versionsAsync();\n  for (let i = 0; i < expOrArray.length; i++) {\n    const manifestCandidate = expOrArray[i];\n    const sdkVersion = manifestCandidate.sdkVersion;\n    if (!sdkVersion) {\n      continue;\n    }\n    const versionObj = sdkVersions[sdkVersion];\n    if (!versionObj) {\n      continue;\n    }\n\n    const isDeprecated = versionObj.isDeprecated || false;\n    if (!isDeprecated) {\n      return manifestCandidate;\n    }\n  }\n  const supportedVersions = Object.keys(sdkVersions);\n  throw new XDLError(\n    ErrorCode.INVALID_MANIFEST,\n    `No compatible manifest found at ${publicUrl}. Please use one of the SDK versions supported: ${JSON.stringify(\n      supportedVersions\n    )}`\n  );\n}\n"],"sourceRoot":"/xdl@51.3.1/src"}