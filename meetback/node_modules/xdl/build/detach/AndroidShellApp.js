// Copyright 2015-present 650 Industries. All rights reserved.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runShellAppModificationsAsync = exports.copyInitialShellAppFilesAsync = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let copyInitialShellAppFilesAsync = exports.copyInitialShellAppFilesAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (androidSrcPath, shellPath, isDetached = false) {
    if (androidSrcPath) {
      yield spawnAsync(`../../tools-public/generate-dynamic-macros-android.sh`, [], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'generating dynamic macros' },
        cwd: _path.default.join(androidSrcPath, 'app'),
        env: _extends({}, process.env, {
          JSON_LOGS: '0'
        })
      }); // populate android template files now since we take out the prebuild step later on
    }

    const initialCopyLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'copying initial shell app files' });

    const copyToShellApp = (() => {
      var _ref3 = _asyncToGenerator(function* (fileName) {
        try {
          yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(androidSrcPath, fileName), _path.default.join(shellPath, fileName));
        } catch (e) {
          // android.iml is only available locally, not on the builders, so don't crash when this happens
          initialCopyLogger.warn(`Warning: Could not copy ${fileName} to shell app directory.`);
        }
      });

      return function copyToShellApp(_x4) {
        return _ref3.apply(this, arguments);
      };
    })();

    if (!isDetached) {
      yield copyToShellApp('expoview');
      yield copyToShellApp('ReactCommon');
      yield copyToShellApp('ReactAndroid');
    }

    yield copyToShellApp('android.iml');
    yield copyToShellApp('app');
    yield copyToShellApp('build.gradle');
    yield copyToShellApp('gradle');
    yield copyToShellApp('gradle.properties');
    yield copyToShellApp('gradlew');
    yield copyToShellApp('settings.gradle');
    yield copyToShellApp('debug.keystore');
    yield copyToShellApp('run.sh');
    yield copyToShellApp('maven'); // this is a symlink
  });

  return function copyInitialShellAppFilesAsync(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

let runShellAppModificationsAsync = exports.runShellAppModificationsAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (context, isDetached = false) {
    const fnLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'running shell app modifications' });

    let shellPath = shellPathForContext(context);
    let url = context.published.url;
    let manifest = context.config; // manifest or app.json
    let releaseChannel = context.published.releaseChannel;

    if (!context.data.privateConfig) {
      fnLogger.warn('Warning: No config file specified.');
    }

    let fullManifestUrl = url.replace('exp://', 'https://');

    let versionCode = 1;
    let javaPackage = manifest.android.package;
    if (manifest.android.versionCode) {
      versionCode = manifest.android.versionCode;
    }

    if (!javaPackage) {
      throw new Error('Must specify androidPackage option (either from manifest or on command line).');
    }

    let name = manifest.name;
    let scheme = manifest.scheme || manifest.detach && manifest.detach.scheme;
    let bundleUrl = manifest.bundleUrl;
    let isFullManifest = !!bundleUrl;
    let version = manifest.version ? manifest.version : '0.0.0';
    let backgroundImages = backgroundImagesForApp(shellPath, manifest, isDetached);
    let splashBackgroundColor = getSplashScreenBackgroundColor(manifest);
    let updatesDisabled = manifest.updates && manifest.updates.enabled === false;

    // Clean build directories
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'ReactAndroid', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'expoview', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'test'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'androidTest'));

    if (isDetached) {
      let appBuildGradle = _path.default.join(shellPath, 'app', 'build.gradle');
      yield regexFileAsync(/\/\* UNCOMMENT WHEN DISTRIBUTING/g, '', appBuildGradle);
      yield regexFileAsync(/END UNCOMMENT WHEN DISTRIBUTING \*\//g, '', appBuildGradle);
      yield regexFileAsync(/\/\/ WHEN_DISTRIBUTING_REMOVE_FROM_HERE/g, '/* REMOVED_WHEN_DISTRIBUTING_FROM_HERE', appBuildGradle);
      yield regexFileAsync(/\/\/ WHEN_DISTRIBUTING_REMOVE_TO_HERE/g, 'REMOVED_WHEN_DISTRIBUTING_TO_HERE */', appBuildGradle);

      // Don't need to compile expoview or ReactAndroid
      // react-native link looks for a \n so we need that. See https://github.com/facebook/react-native/blob/master/local-cli/link/android/patches/makeSettingsPatch.js
      yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.join(shellPath, 'settings.gradle'), `include ':app'\n`);

      yield regexFileAsync('TEMPLATE_INITIAL_URL', url, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'MainActivity.java'));

      const runShPath = _path.default.join(shellPath, 'run.sh');
      yield regexFileAsync('host.exp.exponent/', `${javaPackage}/`, runShPath);
      yield regexFileAsync('LauncherActivity', 'MainActivity', runShPath);
    }

    // Package
    yield regexFileAsync(`applicationId 'host.exp.exponent'`, `applicationId '${javaPackage}'`, _path.default.join(shellPath, 'app', 'build.gradle'));
    yield regexFileAsync(`android:name="host.exp.exponent"`, `android:name="${javaPackage}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Versions
    let buildGradleFile = yield (_fsExtra || _load_fsExtra()).default.readFileSync(_path.default.join(shellPath, 'app', 'build.gradle'), 'utf8');
    let androidVersion = buildGradleFile.match(/versionName '(\S+)'/)[1];
    yield regexFileAsync('VERSION_NAME = null', `VERSION_NAME = "${androidVersion}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    yield deleteLinesInFileAsync(`BEGIN\ VERSIONS`, `END\ VERSIONS`, _path.default.join(shellPath, 'app', 'build.gradle'));
    yield regexFileAsync('// ADD VERSIONS HERE', `versionCode ${versionCode}
    versionName '${version}'`, _path.default.join(shellPath, 'app', 'build.gradle'));

    // Remove Exponent build script
    if (!isDetached) {
      yield regexFileAsync(`preBuild.dependsOn generateDynamicMacros`, ``, _path.default.join(shellPath, 'expoview', 'build.gradle'));
    }

    // change javaMaxHeapSize
    yield regexFileAsync(`javaMaxHeapSize "8g"`, `javaMaxHeapSize "6g"`, _path.default.join(shellPath, 'app', 'build.gradle'));

    // Push notifications
    yield regexFileAsync('"package_name": "host.exp.exponent"', `"package_name": "${javaPackage}"`, _path.default.join(shellPath, 'app', 'google-services.json')); // TODO: actually use the correct file

    // TODO: probably don't need this in both places
    yield regexFileAsync(/host\.exp\.exponent\.permission\.C2D_MESSAGE/g, `${javaPackage}.permission.C2D_MESSAGE`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    if (!isDetached) {
      yield regexFileAsync(/host\.exp\.exponent\.permission\.C2D_MESSAGE/g, `${javaPackage}.permission.C2D_MESSAGE`, _path.default.join(shellPath, 'expoview', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Set INITIAL_URL, SHELL_APP_SCHEME and SHOW_LOADING_VIEW
    yield regexFileAsync('INITIAL_URL = null', `INITIAL_URL = "${url}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    if (scheme) {
      yield regexFileAsync('SHELL_APP_SCHEME = null', `SHELL_APP_SCHEME = "${scheme}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (shouldShowLoadingView(manifest)) {
      yield regexFileAsync('SHOW_LOADING_VIEW_IN_SHELL_APP = false', 'SHOW_LOADING_VIEW_IN_SHELL_APP = true', _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (isDetached) {
      yield regexFileAsync('IS_DETACHED = false', `IS_DETACHED = true`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (updatesDisabled) {
      yield regexFileAsync('ARE_REMOTE_UPDATES_ENABLED = true', 'ARE_REMOTE_UPDATES_ENABLED = false', _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }

    // App name
    yield regexFileAsync('"app_name">Expo', `"app_name">${xmlWeirdAndroidEscape(name)}`, _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'values', 'strings.xml'));

    // Splash Screen background color
    yield regexFileAsync('"splashBackground">#FFFFFF', `"splashBackground">${splashBackgroundColor}`, _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'values', 'colors.xml'));

    // show only background color if LoadingView will appear
    if (shouldShowLoadingView(manifest)) {
      yield regexFileAsync(/<item>.*<\/item>/, '', _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'drawable', 'splash_background.xml'));
    }

    // Change stripe schemes and add meta-data
    const randomID = (_uuid || _load_uuid()).default.v4();
    const newScheme = `<meta-data android:name="standaloneStripeScheme" android:value="${randomID}" />`;
    yield regexFileAsync('<!-- ADD HERE STRIPE SCHEME META DATA -->', newScheme, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    const newSchemeSuffix = `expo.modules.payments.stripe.${randomID}" />`;
    yield regexFileAsync('expo.modules.payments.stripe" />', newSchemeSuffix, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Remove exp:// scheme from LauncherActivity
    yield deleteLinesInFileAsync(`START\ LAUNCHER\ INTENT\ FILTERS`, `END\ LAUNCHER\ INTENT\ FILTERS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Remove LAUNCHER category from HomeActivity
    yield deleteLinesInFileAsync(`START\ HOME\ INTENT\ FILTERS`, `END\ HOME\ INTENT\ FILTERS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    if (isDetached) {
      // Add LAUNCHER category to MainActivity
      yield regexFileAsync('<!-- ADD DETACH INTENT FILTERS HERE -->', `<intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    } else {
      // Add LAUNCHER category to ShellAppActivity
      yield regexFileAsync('<!-- ADD SHELL INTENT FILTERS HERE -->', `<intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Add app-specific intent filters
    const intentFilters = (_lodash || _load_lodash()).default.get(manifest, 'android.intentFilters');
    if (intentFilters) {
      if (isDetached) {
        yield regexFileAsync('<!-- ADD DETACH APP SPECIFIC INTENT FILTERS -->', (0, (_AndroidIntentFilters || _load_AndroidIntentFilters()).default)(intentFilters).join('\n'), _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      } else {
        yield regexFileAsync('<!-- ADD SHELL APP SPECIFIC INTENT FILTERS -->', (0, (_AndroidIntentFilters || _load_AndroidIntentFilters()).default)(intentFilters).join('\n'), _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }
    }

    // Add shell app scheme
    if (scheme) {
      const searchLine = isDetached ? '<!-- ADD DETACH SCHEME HERE -->' : '<!-- ADD SHELL SCHEME HERE -->';
      yield regexFileAsync(searchLine, `<intent-filter>
        <data android:scheme="${scheme}"/>

        <action android:name="android.intent.action.VIEW"/>

        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Add permissions
    if (manifest.android && manifest.android.permissions) {
      const content = yield (_fsExtra || _load_fsExtra()).default.readFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'), 'utf-8');

      // Get the list of optional permissions form manifest
      const permissions = content.replace(/(([\s\S]*<!-- BEGIN OPTIONAL PERMISSIONS -->)|(<!-- END OPTIONAL PERMISSIONS -->[\s\S]*))/g, '').match(/android:name=".+"/g).map(function (p) {
        return p.replace(/(android:name=|")/g, '');
      });

      const whitelist = [];

      manifest.android.permissions.forEach(function (s) {
        if (s.includes('.')) {
          whitelist.push(s);
        } else {
          permissions.forEach(function (identifier) {
            if (identifier.split('.').pop() === s) {
              whitelist.push(identifier);
            }
          });
        }
      });

      // Permissions we need to remove from the generated manifest
      const blacklist = ['android.permission.ACCESS_COARSE_LOCATION', 'android.permission.ACCESS_FINE_LOCATION', 'android.permission.CAMERA', 'android.permission.MANAGE_DOCUMENTS', 'android.permission.READ_CONTACTS', 'android.permission.READ_CALENDAR', 'android.permission.WRITE_CALENDAR', 'android.permission.READ_EXTERNAL_STORAGE', 'android.permission.READ_INTERNAL_STORAGE', 'android.permission.READ_PHONE_STATE', 'android.permission.RECORD_AUDIO', 'android.permission.USE_FINGERPRINT', 'android.permission.VIBRATE', 'android.permission.WRITE_EXTERNAL_STORAGE', 'android.permission.READ_SMS', 'com.anddoes.launcher.permission.UPDATE_COUNT', 'com.android.launcher.permission.INSTALL_SHORTCUT', 'com.google.android.gms.permission.ACTIVITY_RECOGNITION', 'com.google.android.providers.gsf.permission.READ_GSERVICES', 'com.htc.launcher.permission.READ_SETTINGS', 'com.htc.launcher.permission.UPDATE_SHORTCUT', 'com.majeur.launcher.permission.UPDATE_BADGE', 'com.sec.android.provider.badge.permission.READ', 'com.sec.android.provider.badge.permission.WRITE', 'com.sonyericsson.home.permission.BROADCAST_BADGE'].filter(function (p) {
        return !whitelist.includes(p);
      });

      yield deleteLinesInFileAsync(`BEGIN\ OPTIONAL\ PERMISSIONS`, `END\ OPTIONAL\ PERMISSIONS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

      yield regexFileAsync('<!-- ADD PERMISSIONS HERE -->', `
      ${whitelist.map(function (p) {
        return `<uses-permission android:name="${p}" />`;
      }).join('\n')}
      ${blacklist.map(function (p) {
        return `<uses-permission android:name="${p}" tools:node="remove" />`;
      }).join('\n')}
      `, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // OAuth redirect scheme
    yield regexFileAsync('<data android:scheme="host.exp.exponent" android:path="oauthredirect"/>', `<data android:scheme="${javaPackage}" android:path="oauthredirect"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Embed manifest and bundle
    if (isFullManifest) {
      yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'), JSON.stringify(manifest));
      yield saveUrlToPathAsync(bundleUrl, _path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));

      yield regexFileAsync('// START EMBEDDED RESPONSES', `
      // START EMBEDDED RESPONSES
      embeddedResponses.add(new Constants.EmbeddedResponse("${fullManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
      embeddedResponses.add(new Constants.EmbeddedResponse("${bundleUrl}", "assets://shell-app.bundle", "application/javascript"));`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }

    yield regexFileAsync('RELEASE_CHANNEL = "default"', `RELEASE_CHANNEL = "${releaseChannel}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    // Icons
    (0, (_AndroidIcons || _load_AndroidIcons()).createAndWriteIconsToPathAsync)(context, _path.default.join(shellPath, 'app', 'src', 'main', 'res'), isDetached);

    // Splash Background
    if (backgroundImages && backgroundImages.length > 0) {
      // Delete the placeholder images
      (yield (0, (_globby || _load_globby()).default)(['**/shell_launch_background_image.png'], {
        cwd: _path.default.join(shellPath, 'app', 'src', 'main', 'res'),
        absolute: true
      })).forEach(function (filePath) {
        (_fsExtra || _load_fsExtra()).default.removeSync(filePath);
      });

      (_lodash || _load_lodash()).default.forEach(backgroundImages, (() => {
        var _ref6 = _asyncToGenerator(function* (image) {
          if (isDetached) {
            // local file so just copy it
            yield (_fsExtra || _load_fsExtra()).default.copy(image.url, image.path);
          } else {
            yield saveUrlToPathAsync(image.url, image.path);
          }
        });

        return function (_x7) {
          return _ref6.apply(this, arguments);
        };
      })());
    }

    yield (_AssetBundle || _load_AssetBundle()).bundleAsync(manifest.bundledAssets, `${shellPath}/app/src/main/assets`);

    let certificateHash = '';
    let googleAndroidApiKey = '';
    let privateConfig = context.data.privateConfig;
    if (privateConfig) {
      let branch = privateConfig.branch;
      let fabric = privateConfig.fabric;
      let googleMaps = privateConfig.googleMaps;
      let googleSignIn = privateConfig.googleSignIn;

      // Branch
      if (branch) {
        yield regexFileAsync('<!-- ADD BRANCH CONFIG HERE -->', `<meta-data
      android:name="io.branch.sdk.BranchKey"
      android:value="${branch.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Fabric
      if (fabric) {
        yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'fabric.properties'));
        yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'fabric.properties'), `apiSecret=${fabric.buildSecret}\n`);

        yield deleteLinesInFileAsync(`BEGIN\ FABRIC\ CONFIG`, `END\ FABRIC\ CONFIG`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
        yield regexFileAsync('<!-- ADD FABRIC CONFIG HERE -->', `<meta-data
      android:name="io.fabric.ApiKey"
      android:value="${fabric.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Google Maps
      if (googleMaps) {
        yield deleteLinesInFileAsync(`BEGIN\ GOOGLE\ MAPS\ CONFIG`, `END\ GOOGLE\ MAPS\ CONFIG`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
        yield regexFileAsync('<!-- ADD GOOGLE MAPS CONFIG HERE -->', `<meta-data
      android:name="com.google.android.geo.API_KEY"
      android:value="${googleMaps.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Google Login
      if (googleSignIn) {
        certificateHash = googleSignIn.certificateHash;
        googleAndroidApiKey = googleSignIn.apiKey;
      }
    }

    if (manifest.android && manifest.android.googleServicesFile) {
      // google-services.json
      // Used for configuring FCM
      let googleServicesFileContents = manifest.android.googleServicesFile;
      if (isDetached) {
        googleServicesFileContents = yield (_fsExtra || _load_fsExtra()).default.readFile(_path.default.resolve(shellPath, '..', manifest.android.googleServicesFile), 'utf8');
      }
      yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.join(shellPath, 'app', 'google-services.json'), googleServicesFileContents);
    } else {
      yield regexFileAsync('FCM_ENABLED = true', 'FCM_ENABLED = false', _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }

    // Google sign in
    yield regexFileAsync(/"current_key": "(.*?)"/, `"current_key": "${googleAndroidApiKey}"`, _path.default.join(shellPath, 'app', 'google-services.json'));
    yield regexFileAsync(/"certificate_hash": "(.*?)"/, `"certificate_hash": "${certificateHash}"`, _path.default.join(shellPath, 'app', 'google-services.json'));
  });

  return function runShellAppModificationsAsync(_x6) {
    return _ref5.apply(this, arguments);
  };
})();

let buildShellAppAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (context) {
    let shellPath = shellPathForContext(context);

    if (context.build.android) {
      let androidBuildConfiguration = context.build.android;

      try {
        yield (_fsExtra || _load_fsExtra()).default.remove(`shell-unaligned.apk`);
        yield (_fsExtra || _load_fsExtra()).default.remove(`shell.apk`);
      } catch (e) {}
      const gradleArgs = [`assembleProdMinSdkProdKernelRelease`];
      if (process.env.GRADLE_DAEMON_DISABLED) {
        gradleArgs.unshift('--no-daemon');
      }
      yield spawnAsyncThrowError(`./gradlew`, gradleArgs, {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'running gradle' },
        cwd: shellPath
      });
      yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(shellPath, 'app', 'build', 'outputs', 'apk', 'prodMinSdkProdKernel', 'release', 'app-prodMinSdk-prodKernel-release-unsigned.apk'), `shell-unaligned.apk`);
      yield spawnAsync(`jarsigner`, ['-verbose', '-sigalg', 'SHA1withRSA', '-digestalg', 'SHA1', '-storepass', androidBuildConfiguration.keystorePassword, '-keypass', androidBuildConfiguration.keyPassword, '-keystore', androidBuildConfiguration.keystore, 'shell-unaligned.apk', androidBuildConfiguration.keyAlias], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'signing created apk' }
      });
      yield spawnAsync(`zipalign`, ['-v', '4', 'shell-unaligned.apk', 'shell.apk'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'verifying apk alignment' }
      });
      try {
        yield (_fsExtra || _load_fsExtra()).default.remove('shell-unaligned.apk');
      } catch (e) {}
      yield spawnAsync(`jarsigner`, ['-verify', '-verbose', '-certs', '-keystore', androidBuildConfiguration.keystore, 'shell.apk'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'verifying apk' }
      });
      yield (_fsExtra || _load_fsExtra()).default.copy('shell.apk', androidBuildConfiguration.outputFile || '/tmp/shell-signed.apk');
    } else {
      try {
        yield (_fsExtra || _load_fsExtra()).default.remove('shell-debug.apk');
      } catch (e) {}
      yield spawnAsyncThrowError(`./gradlew`, ['assembleDevMinSdkDevKernelDebug'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'running gradle' },
        cwd: shellPath
      });
      yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(shellPath, 'app', 'build', 'outputs', 'apk', 'devMinSdkDevKernel', 'debug', 'app-devMinSdk-devKernel-debug.apk'), `/tmp/shell-debug.apk`);
    }
  });

  return function buildShellAppAsync(_x8) {
    return _ref7.apply(this, arguments);
  };
})();

exports.addDetachedConfigToExp = addDetachedConfigToExp;

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _replaceString;

function _load_replaceString() {
  return _replaceString = _interopRequireDefault(require('replace-string'));
}

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _globby;

function _load_globby() {
  return _globby = _interopRequireDefault(require('globby'));
}

var _uuid;

function _load_uuid() {
  return _uuid = _interopRequireDefault(require('uuid'));
}

var _AndroidIcons;

function _load_AndroidIcons() {
  return _AndroidIcons = require('./AndroidIcons');
}

var _AssetBundle;

function _load_AssetBundle() {
  return _AssetBundle = _interopRequireWildcard(require('./AssetBundle'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = _interopRequireWildcard(require('./ExponentTools'));
}

var _StandaloneBuildFlags;

function _load_StandaloneBuildFlags() {
  return _StandaloneBuildFlags = _interopRequireDefault(require('./StandaloneBuildFlags'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _AndroidIntentFilters;

function _load_AndroidIntentFilters() {
  return _AndroidIntentFilters = _interopRequireDefault(require('./AndroidIntentFilters'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const {
  getManifestAsync,
  saveUrlToPathAsync,
  spawnAsyncThrowError,
  spawnAsync,
  regexFileAsync,
  deleteLinesInFileAsync
} = _ExponentTools || _load_ExponentTools();

const imageKeys = ['mdpi', 'hdpi', 'xhdpi', 'xxhdpi', 'xxxhdpi'];

// Do not call this from anything used by detach
function exponentDirectory(workingDir) {
  if (workingDir) {
    return workingDir;
  } else if (process.env.EXPO_UNIVERSE_DIR) {
    return _path.default.join(process.env.EXPO_UNIVERSE_DIR, 'exponent');
  } else {
    return null;
  }
}

function xmlWeirdAndroidEscape(original) {
  let noAmps = (0, (_replaceString || _load_replaceString()).default)(original, '&', '&amp;');
  let noLt = (0, (_replaceString || _load_replaceString()).default)(noAmps, '<', '&lt;');
  let noGt = (0, (_replaceString || _load_replaceString()).default)(noLt, '>', '&gt;');
  let noApos = (0, (_replaceString || _load_replaceString()).default)(noGt, '"', '\\"');
  return (0, (_replaceString || _load_replaceString()).default)(noApos, "'", "\\'");
}

exports.updateAndroidShellAppAsync = (() => {
  var _ref = _asyncToGenerator(function* (args) {
    let { url, sdkVersion, releaseChannel, workingDir } = args;

    releaseChannel = releaseChannel ? releaseChannel : 'default';
    let manifest = yield getManifestAsync(url, {
      'Exponent-SDK-Version': sdkVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': releaseChannel,
      Accept: 'application/expo+json,application/json'
    });

    let fullManifestUrl = url.replace('exp://', 'https://');
    let bundleUrl = manifest.bundleUrl;

    let shellPath = _path.default.join(exponentDirectory(workingDir), 'android-shell-app');

    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'));
    yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'), JSON.stringify(manifest));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));
    yield saveUrlToPathAsync(bundleUrl, _path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));

    yield deleteLinesInFileAsync(`START\ EMBEDDED\ RESPONSES`, `END\ EMBEDDED\ RESPONSES`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    yield regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
    // ADD EMBEDDED RESPONSES HERE
    // START EMBEDDED RESPONSES
    embeddedResponses.add(new Constants.EmbeddedResponse("${fullManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
    embeddedResponses.add(new Constants.EmbeddedResponse("${bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
    // END EMBEDDED RESPONSES`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    yield regexFileAsync('RELEASE_CHANNEL = "default"', `RELEASE_CHANNEL = "${releaseChannel}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
  });

  function updateAndroidShellAppAsync(_x) {
    return _ref.apply(this, arguments);
  }

  return updateAndroidShellAppAsync;
})();

function getRemoteOrLocalUrl(manifest, key, isDetached) {
  // in detached apps, `manifest` is actually just app.json, so there are no remote url fields
  // we should return a local url starting with file:// instead
  if (isDetached) {
    return (_lodash || _load_lodash()).default.get(manifest, key);
  }
  return (_lodash || _load_lodash()).default.get(manifest, `${key}Url`);
}

function backgroundImagesForApp(shellPath, manifest, isDetached) {
  // returns an array like:
  // [
  //   {url: 'urlToDownload', path: 'pathToSaveTo'},
  //   {url: 'anotherURlToDownload', path: 'anotherPathToSaveTo'},
  // ]
  let basePath = _path.default.join(shellPath, 'app', 'src', 'main', 'res');
  if ((_lodash || _load_lodash()).default.get(manifest, 'android.splash')) {
    var splash = (_lodash || _load_lodash()).default.get(manifest, 'android.splash');
    return (_lodash || _load_lodash()).default.reduce(imageKeys, function (acc, imageKey) {
      let url = getRemoteOrLocalUrl(splash, imageKey, isDetached);
      if (url) {
        acc.push({
          url,
          path: _path.default.join(basePath, `drawable-${imageKey}`, 'shell_launch_background_image.png')
        });
      }

      return acc;
    }, []);
  }

  let url = getRemoteOrLocalUrl(manifest, 'splash.image', isDetached);
  if (url) {
    return [{
      url,
      path: _path.default.join(basePath, 'drawable-xxxhdpi', 'shell_launch_background_image.png')
    }];
  }

  return [];
}

function getSplashScreenBackgroundColor(manifest) {
  let backgroundColor;
  if (manifest.android && manifest.android.splash && manifest.android.splash.backgroundColor) {
    backgroundColor = manifest.android.splash.backgroundColor;
  } else if (manifest.splash && manifest.splash.backgroundColor) {
    backgroundColor = manifest.splash.backgroundColor;
  }

  // Default to white
  if (!backgroundColor) {
    backgroundColor = '#FFFFFF';
  }
  return backgroundColor;
}

/*
  if resizeMode is 'cover' we should show LoadingView:
  using an ImageView, unlike having a BitmapDrawable
  provides a fullscreen image without distortions
*/
function shouldShowLoadingView(manifest) {
  return manifest.android && manifest.android.splash && manifest.android.splash.resizeMode && manifest.android.splash.resizeMode === 'cover' || manifest.splash && manifest.splash.resizeMode && manifest.splash.resizeMode === 'cover';
}

exports.createAndroidShellAppAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (args) {
    let {
      url,
      sdkVersion,
      releaseChannel,
      privateConfigFile,
      configuration,
      keystore,
      alias,
      keystorePassword,
      keyPassword,
      outputFile,
      workingDir
    } = args;

    const exponentDir = exponentDirectory(workingDir);
    let androidSrcPath = _path.default.join(exponentDir, 'android');
    let shellPath = _path.default.join(exponentDir, 'android-shell-app');

    yield (_fsExtra || _load_fsExtra()).default.remove(shellPath);
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(shellPath);

    releaseChannel = releaseChannel ? releaseChannel : 'default';
    let manifest;
    if (args.manifest) {
      manifest = args.manifest;
      (_Logger || _load_Logger()).default.withFields({ buildPhase: 'reading manifest' }).info('Using manifest:', JSON.stringify(manifest));
    } else {
      manifest = yield getManifestAsync(url, {
        'Exponent-SDK-Version': sdkVersion,
        'Exponent-Platform': 'android',
        'Expo-Release-Channel': releaseChannel,
        Accept: 'application/expo+json,application/json'
      });
    }

    configuration = configuration ? configuration : 'Release';

    let privateConfig;
    if (privateConfigFile) {
      let privateConfigContents = yield (_fsExtra || _load_fsExtra()).default.readFile(privateConfigFile, 'utf8');
      privateConfig = JSON.parse(privateConfigContents);
    } else if (manifest.android) {
      privateConfig = manifest.android.config;
    }

    let androidBuildConfiguration;
    if (keystore && alias && keystorePassword && keyPassword) {
      androidBuildConfiguration = {
        keystore,
        keystorePassword,
        keyAlias: alias,
        keyPassword,
        outputFile
      };
    }

    let buildFlags = (_StandaloneBuildFlags || _load_StandaloneBuildFlags()).default.createAndroid(configuration, androidBuildConfiguration);
    let context = (_StandaloneContext || _load_StandaloneContext()).default.createServiceContext(androidSrcPath, null, manifest, privateConfig,
    /* testEnvironment */'none', buildFlags, url, releaseChannel);

    yield copyInitialShellAppFilesAsync(androidSrcPath, shellPath);
    yield runShellAppModificationsAsync(context);

    if (!args.skipBuild) {
      yield buildShellAppAsync(context);
    }
  });

  function createAndroidShellAppAsync(_x5) {
    return _ref4.apply(this, arguments);
  }

  return createAndroidShellAppAsync;
})();

function shellPathForContext(context) {
  if (context.type === 'user') {
    return _path.default.join(context.data.projectPath, 'android');
  } else {
    return _path.default.join(exponentDirectory(context.data.expoSourcePath && _path.default.join(context.data.expoSourcePath, '..')), 'android-shell-app');
  }
}

function addDetachedConfigToExp(exp, context) {
  if (context.type !== 'user') {
    console.warn(`Tried to modify exp for a non-user StandaloneContext, ignoring`);
    return exp;
  }
  let shellPath = shellPathForContext(context);
  let assetsDirectory = _path.default.join(shellPath, 'app', 'src', 'main', 'assets');
  exp.android.publishBundlePath = _path.default.relative(context.data.projectPath, _path.default.join(assetsDirectory, 'shell-app.bundle'));
  exp.android.publishManifestPath = _path.default.relative(context.data.projectPath, _path.default.join(assetsDirectory, 'shell-app-manifest.json'));
  return exp;
}
//# sourceMappingURL=../__sourcemaps__/detach/AndroidShellApp.js.map
